<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Run-at-Time WebSocket Example</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 2em;
    }

    label,
    input {
      margin: 0.3em;
    }

    #messages {
      margin-top: 1em;
      border: 1px solid #aaa;
      padding: 1em;
      height: 200px;
      overflow-y: auto;
    }

    .params-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1em;
    }

    .param-item {
      display: flex;
      flex-direction: column;
    }
  </style>
</head>

<body>
  <h2>Run-at-Time WebSocket Demo</h2>
  <h3>Chart</h3>
  <div style="width: 100%; max-width: 900px; margin: auto;">
    <canvas id="scatterPlot" style="width: 100%; height: 400px;"></canvas>
  </div>
  <form id="runForm">
    <label for="t0">t0 (0–23.999):</label>
    <input type="number" step="0.001" id="t0" name="t0" max="23.999" min="0" required>
    <br>

    <label for="t1">t1 (0–23.999):</label>
    <input type="number" step="0.001" id="t1" name="t1" max="23.999" min="0" required>
    <br>

    <label for="N">N (1–10000):</label>
    <input type="number" id="N" name="N" min="1" max="10000" required>
    <br>

    <h3>Model Parameters</h3>
    <div class="params-grid">
      {% for key, value in params.items() %}
      <div class="param-item">
        <label for="{{ key }}">{{ key }}:</label>
        <input type="text" id="{{ key }}" name="{{ key }}" value="{{ value }}">
      </div>
      {% endfor %}
    </div>

    <button type="submit">Send</button>
  </form>

  <div id="messages"></div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    const wsUrl = 'ws://localhost:8001/ws/run-at-time';
    const messagesDiv = document.getElementById('messages');
    let ws;
    // Parse params from template variable
    const params = JSON.parse('{{ params | tojson | safe }}');

    // Chart.js scatter plot setup
    const canvas = document.getElementById('scatterPlot');
    // Set explicit pixel size to avoid Chart.js infinite resize bug
    canvas.width = 900;
    canvas.height = 400;
    const ctx = canvas.getContext('2d');
    const scatterData = {
      datasets: [{
        label: 'Realtime Output',
        data: [],
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        pointRadius: 4,
      }]
    };
    const scatterChart = new Chart(ctx, {
      type: 'scatter',
      data: scatterData,
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 900 / 400,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'Time (hours)' },
            beginAtZero: true
          },
          y: {
            title: { display: true, text: 'Glucose Response Curve (mg/dL)' },
            beginAtZero: true
          }
        }
      }
    });

    function appendMessage(msg) {
      const el = document.createElement('div');
      el.textContent = msg;
      messagesDiv.appendChild(el);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function addScatterPoints(points) {
      // points: array of {x, y} or single {x, y}
      if (Array.isArray(points)) {
        scatterData.datasets[0].data = points;
      } else if (typeof points === 'object' && points !== null && 'x' in points && 'y' in points) {
        scatterData.datasets[0].data = [points];
      } else {
        console.error('Invalid points format:', points);
        return;
      }
      scatterChart.update();
    }

    function createScatterOnePoint(xdatum, ydatum) {
      /* Create a single scatter plot point datum. */
      return { x: xdatum, y: ydatum };
    }

    function createScatterPointArrayFromDataObject(dataObject) {
      /*
        Create an array of scatter plot points from a data object formatted as {key: value, ...}.
        The keys will be used as the x-coordinates and the values as the y-coordinates.
        ({key: value}) -> {x: key, y: value}
      */
      if (typeof(dataObject) === 'object' && dataObject !== null) {
        return Object.entries(dataObject).map(([key, item]) => createScatterOnePoint(key, item));
      } else if (Array.isArray(dataObject)) {
        return dataObject.map((item, index) => createScatterOnePoint(index, item));
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        appendMessage('Connected to WebSocket server.');
      };
      ws.onmessage = (evt) => {
        // On event: Received WebSocket message...
        appendMessage('Received: ' + evt.data);
        // Debug: log parsed data
        try {
          const data = JSON.parse(evt.data);  // parse WebSocket message (json)
          console.log('Parsed WebSocket data:', data);
          // Accept: Run-At-Time expected output:
          // Expected object: {Gt0: {x: <value>, y: <value>, ...}, Gt1: {...}, ..., Gt: {...}}
          for (const key in data) {
            if (data.hasOwnProperty(key)) {
              console.log(`Creating scatterPointArray from data[${key}] ...`);
              let scatterPoints = createScatterPointArrayFromDataObject(data[key]);
              addScatterPoints(scatterPoints);
            }
          }
        } catch (e) {
          console.warn('WebSocket message not valid JSON or not a point:', e);
        }
      };
      ws.onclose = () => {
        appendMessage('WebSocket connection closed.');
      };
      ws.onerror = (err) => {
        appendMessage('WebSocket error: ' + err);
      };
    }

    connectWebSocket();

    document.getElementById('runForm').onsubmit = function (e) {
      e.preventDefault();
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        appendMessage('WebSocket not connected. Cannot send.');
        return;
      }
      const t0 = parseFloat(document.getElementById('t0').value);
      const t1 = parseFloat(document.getElementById('t1').value);
      const N = parseInt(document.getElementById('N').value);

      // Basic validation
      if (isNaN(t0) || t0 < 0 || t0 > 23.999) {
        appendMessage('Invalid t0');
        return;
      }
      if (isNaN(t1) || t1 < 0 || t1 > 23.999) {
        appendMessage('Invalid t1');
        return;
      }
      if (isNaN(N) || N < 1 || N > 10000) {
        appendMessage('Invalid N');
        return;
      }

      const config = {};
      for (const key in params) {
        const input = document.getElementById(key);
        if (input) {
          let value = input.value;
          // Attempt to convert to number if it's a numeric value
          if (!isNaN(value) && value.trim() !== '') {
            value = parseFloat(value);
          }
          config[key] = value;
        }
      }

      // Clear previous points on new run
      scatterData.datasets[0].data = [];
      scatterChart.update();

      const payload = JSON.stringify({ t0, t1, n: N, config });
      ws.send(payload);
      appendMessage('Sent: ' + payload);
    }
  </script>
</body>

</html>