<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Run-at-Time WebSocket Example</title>
  <style>
    body { font-family: sans-serif; margin: 2em; }
    label, input { margin: 0.3em; }
    #messages { margin-top: 1em; border: 1px solid #aaa; padding: 1em; height: 200px; overflow-y: auto; }
    .params-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 1em; }
    .param-item { display: flex; flex-direction: column; }
  </style>
</head>
<body>
  <h2>Run-at-Time WebSocket Demo</h2>
  <h3>Chart</h3>
  <canvas id="scatterPlot" width="100%" height="400"></canvas>
  <form id="runForm">
    <label for="t0">t0 (0–23.999):</label>
    <input type="number" step="0.001" id="t0" name="t0" max="23.999" min="0" required>
    <br>

    <label for="t1">t1 (0–23.999):</label>
    <input type="number" step="0.001" id="t1" name="t1" max="23.999" min="0" required>
    <br>

    <label for="N">N (1–10000):</label>
    <input type="number" id="N" name="N" min="1" max="10000" required>
    <br>

    <h3>Model Parameters</h3>
    <div class="params-grid">
      {% for key, value in params.items() %}
        <div class="param-item">
          <label for="{{ key }}">{{ key }}:</label>
          <input type="text" id="{{ key }}" name="{{ key }}" value="{{ value }}">
        </div>
      {% endfor %}
    </div>

    <button type="submit">Send</button>
  </form>

  <div id="messages"></div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
  const wsUrl = 'ws://localhost:8001/ws/run-at-time';
  const messagesDiv = document.getElementById('messages');
  let ws;
  // Parse params from template variable
  const params = JSON.parse('{{ params | tojson | safe }}');

    // Chart.js scatter plot setup
    const ctx = document.getElementById('scatterPlot').getContext('2d');
    const scatterData = {
      datasets: [{
        label: 'Realtime Output',
        data: [],
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        pointRadius: 4,
      }]
    };
    const scatterChart = new Chart(ctx, {
      type: 'scatter',
      data: scatterData,
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'x' },
            beginAtZero: true
          },
          y: {
            title: { display: true, text: 'y' },
            beginAtZero: true
          }
        }
      }
    });

    function appendMessage(msg) {
      const el = document.createElement('div');
      el.textContent = msg;
      messagesDiv.appendChild(el);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function addScatterPoints(points) {
      // points: array of {x, y} or single {x, y}
      if (Array.isArray(points)) {
        scatterData.datasets[0].data.push(...points);
      } else if (typeof points === 'object' && points !== null && 'x' in points && 'y' in points) {
        scatterData.datasets[0].data.push(points);
      }
      scatterChart.update();
    }

    function connectWebSocket() {
      ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        appendMessage('Connected to WebSocket server.');
      };
      ws.onmessage = (evt) => {
        appendMessage('Received: ' + evt.data);
        // Try to parse and plot if JSON and has x/y or array of points
        try {
          const data = JSON.parse(evt.data);
          if (Array.isArray(data)) {
            // Array of points
            if (data.length && typeof data[0] === 'object' && 'x' in data[0] && 'y' in data[0]) {
              addScatterPoints(data);
            }
          } else if (typeof data === 'object' && data !== null) {
            // Single point or object with points
            if ('x' in data && 'y' in data) {
              addScatterPoints(data);
            } else if ('points' in data && Array.isArray(data.points)) {
              addScatterPoints(data.points);
            }
          }
        } catch (e) {
          // Not JSON or not a point, ignore for plot
        }
      };
      ws.onclose = () => {
        appendMessage('WebSocket connection closed.');
      };
      ws.onerror = (err) => {
        appendMessage('WebSocket error: ' + err);
      };
    }

    connectWebSocket();

    document.getElementById('runForm').onsubmit = function(e) {
      e.preventDefault();
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        appendMessage('WebSocket not connected. Cannot send.');
        return;
      }
      const t0 = parseFloat(document.getElementById('t0').value);
      const t1 = parseFloat(document.getElementById('t1').value);
      const N = parseInt(document.getElementById('N').value);

      // Basic validation
      if (isNaN(t0) || t0 < 0 || t0 > 23.999) {
        appendMessage('Invalid t0');
        return;
      }
      if (isNaN(t1) || t1 < 0 || t1 > 23.999) {
        appendMessage('Invalid t1');
        return;
      }
      if (isNaN(N) || N < 1 || N > 10000) {
        appendMessage('Invalid N');
        return;
      }

      const config = {};
      for (const key in params) {
        const input = document.getElementById(key);
        if (input) {
          let value = input.value;
          // Attempt to convert to number if it's a numeric value
          if (!isNaN(value) && value.trim() !== '') {
            value = parseFloat(value);
          }
          config[key] = value;
        }
      }

      // Clear previous points on new run
      scatterData.datasets[0].data = [];
      scatterChart.update();

      const payload = JSON.stringify({ t0, t1, n: N, config });
      ws.send(payload);
      appendMessage('Sent: ' + payload);
    }
  </script>
</body>
</html>