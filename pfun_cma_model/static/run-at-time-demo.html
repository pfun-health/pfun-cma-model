<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Run-at-Time WebSocket Example</title>
  <link rel="stylesheet" href="{{ url_for('static', path='style.css') }}">
</head>

<body>
  <h2>Run-at-Time WebSocket Demo</h2>
  <h3>Chart</h3>
  <div style="width: 100%; max-width: 900px; margin: auto;">
    <canvas id="scatterPlot" style="width: 100%; height: 400px;"></canvas>
  </div>
  <form id="runForm">

    <div class="form-row">
      <label for="t0" class="tooltip">t0 (0.0, 24.0):
        <span class="tooltiptext">Simulation start time (decimal hours).</span>
      </label>
      <input type="number" step="0.2" id="t0" name="t0" max="23.999" min="0" value="4" required>
    </div>

    <div class="form-row">
      <label for="t1" class="tooltip">t1 (0–23.999):
        <span class="tooltiptext">Simulation end time (decimal hours).<br>Note: t1 must be greater than t0.</span>
      </label>
      <input type="number" step="0.2" id="t1" name="t1" max="23.999" min="0" value="20" required>
    </div>

    <div class="form-row">
      <label for="N" class="tooltip">N (1–10000):
        <span class="tooltiptext">Number of points to simulate.<br>Note: N must be a positive integer.</span>
      </label>
      <input type="number" id="N" name="N" min="1" max="10000" value="100" required>
    </div>
    </head>
    <style>
      .form-row {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
        gap: 1em;
      }

      .tooltip {
        position: relative;
        cursor: pointer;
        border-bottom: 1px dotted #555;
      }

      .tooltip .tooltiptext {
        visibility: hidden;
        width: 220px;
        background-color: #333;
        color: #fff;
        text-align: left;
        border-radius: 6px;
        padding: 8px;
        position: absolute;
        z-index: 1;
        bottom: 125%;
        left: 50%;
        margin-left: -110px;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 0.95em;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }

      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
      }
    </style>

    <h3>Model Parameters</h3>
    <div class="params-grid">
      {% for key, value in params.items() %}
      <div class="param-item">
        <label for="{{ key }}">{{ key }}:</label>
        <span class="tooltip">
          <span class="tooltiptext">{{ value.description }}</span>
        </span>
        <input type="numeric" id="{{ key }}" name="{{ key }}" value="{{ value.value }}" step="{{ value.step }}"
          min="{{ value.min }}" max="{{ value.max }}" required>
      </div>
      {% endfor %}
    </div>

    <button type="submit">Send</button>
  </form>

  <div id="messages"></div>

  <!-- Chart.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.5.0/chart.umd.js"
    integrity="sha512-D4pL3vNgjkHR/qq+nZywuS6Hg1gwR+UzrdBW6Yg8l26revKyQHMgPq9CLJ2+HHalepS+NuGw1ayCCsGXu9JCXA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Socket.IO CDN -->
  <!-- Note: Ensure you have the correct version matching your server -->
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"
    integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+"
    crossorigin="anonymous"></script>

  <script>

    const messagesDiv = document.getElementById('messages');
    let socket;
    // Parse params from template variable
    const params = JSON.parse('{{ params | tojson | safe }}');

    // Chart.js scatter plot setup
    const canvas = document.getElementById('scatterPlot');
    // Set explicit pixel size to avoid Chart.js infinite resize bug
    canvas.width = 900;
    canvas.height = 400;
    const ctx = canvas.getContext('2d');
    const scatterData = {
      datasets: [{
        label: 'Glucose Response Curve',
        data: [],
        backgroundColor: 'rgba(54, 162, 235, 0.7)',
        pointRadius: 4,
      }]
    };
    // Custom plugin for onioning/fade effect
    const onionFadePlugin = {
      id: 'onionFade',
      beforeDatasetsDraw(chart, args, options) {
        const ctx = chart.ctx;
        chart.data.datasets.forEach((dataset, i) => {
          dataset.data.forEach((pt, idx) => {
            if (pt._fade) {
              const meta = chart.getDatasetMeta(i);
              const point = meta.data[idx];
              if (point) {
                ctx.save();
                ctx.globalAlpha = 0.2;
                point.draw(ctx);
                ctx.restore();
              }
            }
          });
        });
      }
    };

    const fadeDuration = 50; // ms
    const scatterChart = new Chart(ctx, {
      type: 'scatter',
      data: scatterData,
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 900 / 400,
        plugins: {
          onionFade: {
            fadeDuration: fadeDuration // Duration for fade effect in ms
          },
        },
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: 'Time (hours)' },
            beginAtZero: true,
          },
          y: {
            title: { display: true, text: 'Glucose Response Curve (normalised [0.0, 2.0])' },
            beginAtZero: true
          }
        }
      },
      plugins: [onionFadePlugin]
    });
    // !!! Disable all animations globally
    //chart.options.animation = false; // disables all animations

    function appendMessage(msg) {
      const el = document.createElement('div');
      el.textContent = msg;
      messagesDiv.appendChild(el);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    function addScatterPoints(points) {
      // Smoothly transition to new points using onioning effect
      // Keep previous points and fade them out, fade in new points
      const prevData = scatterData.datasets[0].data.slice();
      let newData;
      if (Array.isArray(points)) {
        newData = points;
      } else if (typeof points === 'object' && points !== null && 'x' in points && 'y' in points) {
        newData = [points];
      } else {
        console.error('Invalid points format:', points);
        return;
      }

      // Onioning: overlay previous points with alpha, fade in new points
      scatterData.datasets[0].data = prevData.map(pt => ({ ...pt, _fade: true }));
      scatterChart.update();
      setTimeout(() => {
        scatterData.datasets[0].data = newData.map(pt => ({ ...pt, _fade: false }));
        scatterChart.update('active');
      }, fadeDuration); // 250ms fade effect
    }

    function createScatterOnePoint(xdatum, ydatum) {
      /* Create a single scatter plot point datum. */
      return { x: xdatum, y: ydatum };
    }

    function createScatterPointArrayFromDataObject(dataObject) {
      /*
        Create an array of scatter plot points from a data object formatted as {key: value, ...}.
        The keys will be used as the x-coordinates and the values as the y-coordinates.
        ({key: value}) -> {x: key, y: value}
      */
      if (typeof (dataObject) === 'object' && dataObject !== null) {
        return Object.entries(dataObject).map(([key, item]) => createScatterOnePoint(key, item));
      } else if (Array.isArray(dataObject)) {
        return dataObject.map((item, index) => createScatterOnePoint(index, item));
      }
    }


    // WebSocket connection setup
    const wsUrl = '{{ ws_prefix }}://{{ host }}:{{ port }}/';

    function connectSocketIO() {
      if (socket && socket.connected) {
        socket.disconnect();
      }
      // Socket.IO expects the base URL, not the full ws path
      // We'll use the namespace/endpoint as the path

      socket = io(wsUrl, { transports: ['websocket'] });

      socket.on('connect', () => {
        appendMessage('Connected to Socket.IO server.');
      });

      socket.on('disconnect', () => {
        appendMessage('Socket.IO connection closed.');
      });

      socket.on('connect_error', (err) => {
        appendMessage('Socket.IO connection error: ' + err.message);
      });

      // Listen for messages from server (event name may need to match backend)
      socket.on('message', (data) => {
        appendMessage('Received: ' + JSON.stringify(data));
        try {
          // If data is a string, try to parse as JSON
          let parsed = data;
          if (typeof data === 'string') {
            parsed = JSON.parse(data);
          }
          for (const key in parsed) {
            if (parsed.hasOwnProperty(key)) {
              let scatterPoints = createScatterPointArrayFromDataObject(parsed[key]);
              addScatterPoints(scatterPoints);
            }
          }
        } catch (e) {
          console.warn('Socket.IO message not valid JSON or not a point:', e);
        }
      });
    }

    // Helper: trigger chart transition and websocket reconnect
    function triggerChartUpdateAndReconnect() {
      // Onion fade out current points
      scatterData.datasets[0].data = scatterData.datasets[0].data.map(pt => ({ ...pt, _fade: true }));
      scatterChart.update();
      setTimeout(() => {
        scatterData.datasets[0].data = [];
        scatterChart.update('active');
      }, fadeDuration);
    }

    // Initial connection
    connectSocketIO();

    // Event-driven: update on parameter change
    document.querySelectorAll('#runForm input').forEach(input => {
      input.addEventListener('change', () => {
        triggerChartUpdateAndReconnect();
      });
    });

    document.getElementById('runForm').onsubmit = function (e) {
      e.preventDefault();
      triggerChartUpdateAndReconnect();
      setTimeout(() => {
        if (!socket || !socket.connected) {
          appendMessage('Socket.IO not connected. Cannot send.');
          return;
        }
        const t0 = parseFloat(document.getElementById('t0').value);
        const t1 = parseFloat(document.getElementById('t1').value);
        const N = parseInt(document.getElementById('N').value);

        // Basic validation
        if (isNaN(t0) || t0 < 0 || t0 > 23.999) {
          appendMessage('Invalid t0');
          return;
        }
        if (isNaN(t1) || t1 < 0 || t1 > 23.999) {
          appendMessage('Invalid t1');
          return;
        }
        if (isNaN(N) || N < 1 || N > 10000) {
          appendMessage('Invalid N');
          return;
        }

        const config = {};
        for (const key in params) {
          const input = document.getElementById(key);
          if (input) {
            let value = input.value;
            if (!isNaN(value) && value.trim() !== '') {
              value = parseFloat(value);
            }
            config[key] = value;
          }
        }

        const payload = { t0, t1, n: N, config };
        // Use a custom event name, e.g. 'run', or 'run-at-time', as expected by backend
        socket.emit('run', payload);
        appendMessage('Sent: ' + JSON.stringify(payload));
      }, 100); // Wait for fade out and reconnect
    }
  </script>
</body>

</html>